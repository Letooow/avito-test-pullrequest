/*
 * PR Reviewer Assignment Service (Test Task, Fall 2025)
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"avito-test/internal/domain"
	"avito-test/internal/usecase"
	"errors"
	"log"
	"net/http"

	"github.com/gin-gonic/gin"
)

type TeamsAPI struct {
	teamUC usecase.Team
}

// Конструктор, чтобы удобно собирать в main.
func NewTeamsAPI(teamUC usecase.Team) TeamsAPI {
	return TeamsAPI{teamUC: teamUC}
}

// DTO для ответа по спецификации /components/schemas/Team
type teamMemberResponse struct {
	UserID   string `json:"user_id"`
	Username string `json:"username"`
	IsActive bool   `json:"is_active"`
}

type teamResponse struct {
	TeamName string               `json:"team_name"`
	Members  []teamMemberResponse `json:"members"`
}

func mapTeamToResponse(team *domain.Team) teamResponse {
	resp := teamResponse{
		TeamName: team.Name,
		Members:  make([]teamMemberResponse, 0, len(team.Members)),
	}
	if team.Members != nil {
		for _, m := range team.Members {
			resp.Members = append(resp.Members, teamMemberResponse{
				UserID:   m.ID,
				Username: m.Username,
				IsActive: m.IsActive,
			})
		}
	}
	return resp
}

// POST /team/add
// Создать команду с участниками (создаёт/обновляет пользователей)
func (api *TeamsAPI) TeamAddPost(c *gin.Context) {
	var body struct {
		TeamName string `json:"team_name" binding:"required"`
		Members  []struct {
			UserID   string `json:"user_id" binding:"required"`
			Username string `json:"username" binding:"required"`
			IsActive bool   `json:"is_active"`
		} `json:"members" binding:"required"`
	}

	if err := c.ShouldBindJSON(&body); err != nil {
		writeError(c, http.StatusBadRequest, errCodeBadRequest, err.Error())
		return
	}
	if body.TeamName == "" {
		writeError(c, http.StatusBadRequest, errCodeBadRequest, "team_name is required")
		return
	}

	team := &domain.Team{
		Name: body.TeamName,
	}

	members := make([]domain.User, 0, len(body.Members))
	for _, m := range body.Members {
		members = append(members, domain.User{
			ID:       m.UserID,
			Username: m.Username,
			IsActive: m.IsActive,
		})
	}

	team, err := api.teamUC.CreateTeam(c.Request.Context(), team, members)

	switch {
	case err == nil:
		// 201 + { "team": Team }
		resp := struct {
			Team teamResponse `json:"team"`
		}{
			Team: mapTeamToResponse(team),
		}
		c.JSON(http.StatusCreated, resp)
		return

	case errors.Is(err, usecase.ErrTeamAlreadyExists):
		// 400 TEAM_EXISTS
		writeError(c, http.StatusBadRequest, errCodeTeamExists, err.Error())
		return

	default:
		log.Printf("%+v", err)
		writeError(c, http.StatusInternalServerError, errCodeInternal, err.Error())
		return
	}
}

// GET /team/get
// Получить команду с участниками
func (api *TeamsAPI) TeamGetGet(c *gin.Context) {
	teamName := c.Query("team_name")
	if teamName == "" {
		writeError(c, http.StatusBadRequest, errCodeBadRequest, "team_name is required")
		return
	}

	team, err := api.teamUC.GetTeam(c.Request.Context(), teamName)

	switch {
	case errors.Is(err, usecase.ErrTeamNotFound):
		writeError(c, http.StatusNotFound, errCodeNotFound, err.Error())
		return
	case err != nil:
		writeError(c, http.StatusInternalServerError, errCodeInternal, err.Error())
		return
	}

	c.JSON(http.StatusOK, mapTeamToResponse(team))
}
