/*
 * PR Reviewer Assignment Service (Test Task, Fall 2025)
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"avito-test/internal/domain"
	"avito-test/internal/usecase"
	"errors"
	"net/http"

	"github.com/gin-gonic/gin"
)

type UsersAPI struct {
	userUC usecase.User
}

func NewUsersAPI(userUC usecase.User) UsersAPI {
	return UsersAPI{userUC: userUC}
}

type userResponse struct {
	UserID   string `json:"user_id"`
	Username string `json:"username"`
	TeamName string `json:"team_name"`
	IsActive bool   `json:"is_active"`
}

func mapUserToResponse(u *domain.User) userResponse {
	return userResponse{
		UserID:   u.ID,
		Username: u.Username,
		IsActive: u.IsActive,
	}
}

// GET /users/getReview
// Получить PR'ы, где пользователь назначен ревьювером

func (api *UsersAPI) UsersGetReviewGet(c *gin.Context) {
	userID := c.Query("user_id")
	if userID == "" {
		writeError(c, http.StatusBadRequest, errCodeBadRequest, "user_id is required")
		return
	}

	prs, err := api.userUC.GetUserPullRequests(c.Request.Context(), userID)

	switch {
	case errors.Is(err, usecase.ErrMemberNotFound):
		writeError(c, http.StatusNotFound, errCodeNotFound, err.Error())
		return
	case err != nil:
		writeError(c, http.StatusInternalServerError, errCodeInternal, err.Error())
		return
	}

	type pullRequestShort struct {
		PullRequestID   string `json:"pull_request_id"`
		PullRequestName string `json:"pull_request_name"`
		AuthorID        string `json:"author_id"`
		Status          string `json:"status"`
	}

	out := struct {
		UserID       string             `json:"user_id"`
		PullRequests []pullRequestShort `json:"pull_requests"`
	}{
		UserID:       userID,
		PullRequests: make([]pullRequestShort, 0, len(prs)),
	}

	for _, pr := range prs {
		out.PullRequests = append(out.PullRequests, pullRequestShort{
			PullRequestID:   pr.ID,
			PullRequestName: pr.Name,
			AuthorID:        pr.AuthorID,
			Status:          string(pr.Status),
		})
	}

	c.JSON(http.StatusOK, out)
}

// POST /users/setIsActive
// Установить флаг активности пользователя

func (api *UsersAPI) UsersSetIsActivePost(c *gin.Context) {
	var body struct {
		UserID   string `json:"user_id" binding:"required"`
		IsActive bool   `json:"is_active" binding:"required"`
	}
	if err := c.ShouldBindJSON(&body); err != nil {
		writeError(c, http.StatusBadRequest, errCodeBadRequest, err.Error())
		return
	}

	user, err := api.userUC.SetActive(c.Request.Context(), body.UserID, body.IsActive)

	switch {
	case errors.Is(err, usecase.ErrMemberNotFound):
		writeError(c, http.StatusNotFound, errCodeNotFound, err.Error())
		return
	case err != nil:
		writeError(c, http.StatusInternalServerError, errCodeInternal, err.Error())
		return
	}

	resp := struct {
		User userResponse `json:"user"`
	}{
		User: mapUserToResponse(user),
	}

	c.JSON(http.StatusOK, resp)
}
