// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const assignUserPullRequest = `-- name: AssignUserPullRequest :exec
INSERT INTO users_pull_requests (pullrequestid, userid, role) VALUES ($1, $2, $3)
`

type AssignUserPullRequestParams struct {
	Pullrequestid string `db:"pullrequestid" json:"pullrequestid"`
	Userid        string `db:"userid" json:"userid"`
	Role          string `db:"role" json:"role"`
}

func (q *Queries) AssignUserPullRequest(ctx context.Context, arg AssignUserPullRequestParams) error {
	_, err := q.db.ExecContext(ctx, assignUserPullRequest, arg.Pullrequestid, arg.Userid, arg.Role)
	return err
}

const createPullRequest = `-- name: CreatePullRequest :exec
INSERT INTO pull_requests (pullrequestid, name, status) VALUES ($1, $2, $3)
`

type CreatePullRequestParams struct {
	Pullrequestid string         `db:"pullrequestid" json:"pullrequestid"`
	Name          sql.NullString `db:"name" json:"name"`
	Status        string         `db:"status" json:"status"`
}

func (q *Queries) CreatePullRequest(ctx context.Context, arg CreatePullRequestParams) error {
	_, err := q.db.ExecContext(ctx, createPullRequest, arg.Pullrequestid, arg.Name, arg.Status)
	return err
}

const createTeam = `-- name: CreateTeam :exec
INSERT INTO teams (teamname) VALUES ($1)
`

func (q *Queries) CreateTeam(ctx context.Context, teamname string) error {
	_, err := q.db.ExecContext(ctx, createTeam, teamname)
	return err
}

const deletePullRequestAssignOfUser = `-- name: DeletePullRequestAssignOfUser :exec
DELETE FROM users_pull_requests WHERE pullrequestid = $1 AND userid = $2
`

type DeletePullRequestAssignOfUserParams struct {
	Pullrequestid string `db:"pullrequestid" json:"pullrequestid"`
	Userid        string `db:"userid" json:"userid"`
}

func (q *Queries) DeletePullRequestAssignOfUser(ctx context.Context, arg DeletePullRequestAssignOfUserParams) error {
	_, err := q.db.ExecContext(ctx, deletePullRequestAssignOfUser, arg.Pullrequestid, arg.Userid)
	return err
}

const getListOfUsersByPullRequestID = `-- name: GetListOfUsersByPullRequestID :many
SELECT userid, role FROM users_pull_requests WHERE pullrequestid = $1
`

type GetListOfUsersByPullRequestIDRow struct {
	Userid string `db:"userid" json:"userid"`
	Role   string `db:"role" json:"role"`
}

func (q *Queries) GetListOfUsersByPullRequestID(ctx context.Context, pullrequestid string) ([]GetListOfUsersByPullRequestIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getListOfUsersByPullRequestID, pullrequestid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListOfUsersByPullRequestIDRow
	for rows.Next() {
		var i GetListOfUsersByPullRequestIDRow
		if err := rows.Scan(&i.Userid, &i.Role); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPullRequestByID = `-- name: GetPullRequestByID :one
SELECT pullrequestid, name, status, createdat, mergedat FROM pull_requests WHERE pullrequestid = $1
`

func (q *Queries) GetPullRequestByID(ctx context.Context, pullrequestid string) (PullRequest, error) {
	row := q.db.QueryRowContext(ctx, getPullRequestByID, pullrequestid)
	var i PullRequest
	err := row.Scan(
		&i.Pullrequestid,
		&i.Name,
		&i.Status,
		&i.Createdat,
		&i.Mergedat,
	)
	return i, err
}

const getPullRequests = `-- name: GetPullRequests :many
SELECT pullrequestid, name, status, createdat, mergedat FROM pull_requests
`

func (q *Queries) GetPullRequests(ctx context.Context) ([]PullRequest, error) {
	rows, err := q.db.QueryContext(ctx, getPullRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PullRequest
	for rows.Next() {
		var i PullRequest
		if err := rows.Scan(
			&i.Pullrequestid,
			&i.Name,
			&i.Status,
			&i.Createdat,
			&i.Mergedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamByName = `-- name: GetTeamByName :one
SELECT teamname FROM teams WHERE teamname = $1
`

func (q *Queries) GetTeamByName(ctx context.Context, teamname string) (string, error) {
	row := q.db.QueryRowContext(ctx, getTeamByName, teamname)
	err := row.Scan(&teamname)
	return teamname, err
}

const getTeams = `-- name: GetTeams :many
SELECT teamname FROM teams
`

func (q *Queries) GetTeams(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var teamname string
		if err := rows.Scan(&teamname); err != nil {
			return nil, err
		}
		items = append(items, teamname)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT userid, username, isactive FROM users WHERE userid = $1
`

func (q *Queries) GetUserByID(ctx context.Context, userid string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, userid)
	var i User
	err := row.Scan(&i.Userid, &i.Username, &i.Isactive)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT userid, username, isactive FROM users
`

func (q *Queries) GetUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(&i.Userid, &i.Username, &i.Isactive); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersAssignedPullRequest = `-- name: GetUsersAssignedPullRequest :many
SELECT pull_requests.pullrequestid, role FROM pull_requests, users_pull_requests WHERE pull_requests.pullrequestid = (SELECT pullrequestid FROM users_pull_requests WHERE users_pull_requests.userid = $1)
`

type GetUsersAssignedPullRequestRow struct {
	Pullrequestid string `db:"pullrequestid" json:"pullrequestid"`
	Role          string `db:"role" json:"role"`
}

func (q *Queries) GetUsersAssignedPullRequest(ctx context.Context, userid string) ([]GetUsersAssignedPullRequestRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersAssignedPullRequest, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersAssignedPullRequestRow
	for rows.Next() {
		var i GetUsersAssignedPullRequestRow
		if err := rows.Scan(&i.Pullrequestid, &i.Role); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByTeamName = `-- name: GetUsersByTeamName :many
SELECT u.userid,
       u.username,
       u.isactive
FROM users u
         JOIN users_team ut ON ut.userid = u.userid
WHERE ut.teamname = $1
`

func (q *Queries) GetUsersByTeamName(ctx context.Context, teamname string) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getUsersByTeamName, teamname)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(&i.Userid, &i.Username, &i.Isactive); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersTeams = `-- name: GetUsersTeams :many
SELECT t.teamname
FROM teams t
         JOIN users_team ut ON ut.teamname = t.teamname
WHERE ut.userid = $1
`

func (q *Queries) GetUsersTeams(ctx context.Context, userid string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUsersTeams, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var teamname string
		if err := rows.Scan(&teamname); err != nil {
			return nil, err
		}
		items = append(items, teamname)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveUser = `-- name: SaveUser :exec
INSERT INTO users (userid, username, isactive)
VALUES ($1, $2, $3)
`

type SaveUserParams struct {
	Userid   string `db:"userid" json:"userid"`
	Username string `db:"username" json:"username"`
	Isactive bool   `db:"isactive" json:"isactive"`
}

func (q *Queries) SaveUser(ctx context.Context, arg SaveUserParams) error {
	_, err := q.db.ExecContext(ctx, saveUser, arg.Userid, arg.Username, arg.Isactive)
	return err
}

const saveUserTeam = `-- name: SaveUserTeam :exec
INSERT INTO users_team (teamname, userid) VALUES ($1, $2)
`

type SaveUserTeamParams struct {
	Teamname string `db:"teamname" json:"teamname"`
	Userid   string `db:"userid" json:"userid"`
}

func (q *Queries) SaveUserTeam(ctx context.Context, arg SaveUserTeamParams) error {
	_, err := q.db.ExecContext(ctx, saveUserTeam, arg.Teamname, arg.Userid)
	return err
}

const updatePullRequestStatus = `-- name: UpdatePullRequestStatus :exec
UPDATE pull_requests SET status = $1, mergedat = $2 WHERE pullrequestid = $3
`

type UpdatePullRequestStatusParams struct {
	Status        string       `db:"status" json:"status"`
	Mergedat      sql.NullTime `db:"mergedat" json:"mergedat"`
	Pullrequestid string       `db:"pullrequestid" json:"pullrequestid"`
}

func (q *Queries) UpdatePullRequestStatus(ctx context.Context, arg UpdatePullRequestStatusParams) error {
	_, err := q.db.ExecContext(ctx, updatePullRequestStatus, arg.Status, arg.Mergedat, arg.Pullrequestid)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users SET username = $1, isactive = $2 WHERE userid = $3
`

type UpdateUserParams struct {
	Username string `db:"username" json:"username"`
	Isactive bool   `db:"isactive" json:"isactive"`
	Userid   string `db:"userid" json:"userid"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser, arg.Username, arg.Isactive, arg.Userid)
	return err
}
